<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Coloriage Magique – Les jeux d'Élise</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <!-- Tailwind (CDN) pour un style rapide et propre) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + ReactDOM (UMD) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Babel pour transpiler JSX directement dans le navigateur (pratique pour un fichier unique) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html, body { height: 100%; }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type="number"] { -moz-appearance: textfield; }
  </style>
</head>
<body class="min-h-screen bg-slate-50 text-slate-900">
  <div class="max-w-6xl mx-auto p-6">
    <a href="index.html" class="inline-block text-sm text-slate-500 hover:text-slate-700 mb-2">← Retour aux jeux</a>
    <div id="root"></div>
  </div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    // ------------------------------ Helpers ------------------------------
    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
    const mulberry32 = (a) => () => {
      let t = (a += 0x6d2b79f5);
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };

    function kmeans(points, k, maxIter = 20, seedVal = 1) {
      if (!points.length) return { centers: [], labels: [] };
      k = clamp(k, 1, points.length);
      const rand = mulberry32(seedVal);
      const centers = [];
      const used = new Set();
      while (centers.length < k) {
        const idx = Math.floor(rand() * points.length);
        if (!used.has(idx)) { used.add(idx); centers.push(points[idx].slice()); }
      }
      const labels = new Array(points.length).fill(0);
      const dist2 = (a, b) => (a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2;
      for (let it=0; it<maxIter; it++) {
        let changed = false;
        for (let i=0; i<points.length; i++) {
          let best = 0, bestd = Infinity;
          for (let c=0; c<centers.length; c++) {
            const d = dist2(points[i], centers[c]);
            if (d < bestd) { bestd = d; best = c; }
          }
          if (labels[i] !== best) { labels[i] = best; changed = true; }
        }
        const sums = Array.from({length:k}, () => [0,0,0,0]);
        for (let i=0; i<points.length; i++) {
          const c = labels[i];
          sums[c][0]+=points[i][0]; sums[c][1]+=points[i][1]; sums[c][2]+=points[i][2]; sums[c][3]++;
        }
        for (let c=0; c<k; c++) if (sums[c][3]>0) centers[c] = [sums[c][0]/sums[c][3], sums[c][1]/sums[c][3], sums[c][2]/sums[c][3]];
        if (!changed) break;
      }
      return { centers, labels };
    }

    // Générateur d'expressions selon la difficulté & le mode — jamais de résultat négatif, divisions exactes uniquement.
    function exprBankForResult(target, mode, rng, difficulty = 'facile') {
      const list = [];
      const pushUnique = (s) => { if (!list.includes(s)) list.push(s); };

      // 2 termes de base
      const add2 = () => { for (let a=0; a<=target; a++){ const b = target - a; if (b>=0) pushUnique(`${a} + ${b}`);} };
      const sub2 = () => { for (let a=target; a<=target+40; a++){ const b = a - target; if (b>=0) pushUnique(`${a} - ${b}`);} };
      const mult2 = () => { for (let a=1; a<=20; a++){ if (target % a === 0){ const b = target / a; if (b>=1 && b<=20) pushUnique(`${a} × ${b}`);} } };
      const div2  = () => { for (let b=1; b<=20; b++){ const a = target * b; if (a<=800) pushUnique(`${a} ÷ ${b}`);} };

      if (["add","addsub","mix"].includes(mode)) add2();
      if (["addsub","mix"].includes(mode))       sub2();
      if (["mult","multdiv","mix"].includes(mode)) mult2();
      if (["multdiv","mix"].includes(mode))        div2();

      const maxN = difficulty === 'facile' ? 0 : (difficulty === 'moyen' ? 12 : 20);
      if (maxN > 0) {
        // 3 termes (>=0)
        if (["add","addsub","mix"].includes(mode)) {
          for (let a=0; a<=maxN; a++) for (let b=0; b<=maxN; b++) {
            const c = target - a - b; if (c>=0 && c<=maxN) pushUnique(`${a} + ${b} + ${c}`);
          }
          if (difficulty === 'difficile') {
            for (let a=0; a<=maxN; a++) for (let b=0; b<=maxN; b++) {
              const c = a + b - target; if (c>=0 && c<=maxN) pushUnique(`${a} + ${b} - ${c}`);
            }
          }
        }
        if (["mult","multdiv","mix"].includes(mode)) {
          const lim = Math.max(12, Math.min(20, maxN));
          for (let a=1; a<=lim; a++) for (let b=1; b<=lim; b++) {
            const prod = a*b;
            const cAdd = target - prod; if (cAdd>=0 && cAdd<=maxN) pushUnique(`${a} × ${b} + ${cAdd}`);
            const cSub = prod - target; if (cSub>=0 && cSub<=maxN) pushUnique(`${a} × ${b} - ${cSub}`);
          }
        }
        if (difficulty === 'difficile' && ["mult","multdiv","mix"].includes(mode)) {
          for (let a=1; a<=12; a++) for (let b=1; b<=12; b++) for (let c=1; c<=12; c++) {
            if (a*b % c === 0 && (a*b)/c === target) pushUnique(`(${a} × ${b}) ÷ ${c}`);
          }
        }

        // 4 termes (difficile) — >= 0
        if (difficulty === 'difficile') {
          if (["add","addsub","mix"].includes(mode)) {
            for (let a=0; a<=maxN; a++) for (let b=0; b<=maxN; b++) for (let c=0; c<=maxN; c++) {
              const d = target - a - b - c; if (d>=0 && d<=maxN) pushUnique(`${a} + ${b} + ${c} + ${d}`);
            }
            for (let a=0; a<=maxN; a++) for (let b=0; b<=maxN; b++) for (let c=0; c<=maxN; c++) {
              const d = a + b + c - target; if (d>=0 && d<=maxN) pushUnique(`${a} + ${b} + ${c} - ${d}`);
            }
          }
          if (["mult","multdiv","mix"].includes(mode)) {
            const lim = 12;
            for (let a=1; a<=lim; a++) for (let b=1; b<=lim; b++) for (let c=0; c<=maxN; c++) {
              const prod = a*b;
              const dAdd = target - prod - c; if (dAdd>=0 && dAdd<=maxN) pushUnique(`${a} × ${b} + ${c} + ${dAdd}`);
              const dSub = prod + c - target; if (dSub>=0 && dSub<=maxN) pushUnique(`${a} × ${b} + ${c} - ${dSub}`);
              const dSub2 = prod - c - target; if (dSub2>=0 && dSub2<=maxN) pushUnique(`${a} × ${b} - ${c} - ${dSub2}`);
            }
            for (let a=1; a<=lim; a++) for (let b=1; b<=lim; b++) for (let c=1; c<=lim; c++) {
              if (a*b % c === 0) {
                const base = (a*b)/c;
                const d = target - base; if (d>=0 && d<=maxN) pushUnique(`(${a} × ${b}) ÷ ${c} + ${d}`);
              }
            }
          }
        }
      }

      for (let i=list.length-1; i>0; i--) { const j = Math.floor(rng()*(i+1)); [list[i], list[j]] = [list[j], list[i]]; }
      return list;
    }

    function mergeRectangles(labels, W, H) {
      const rects = [];
      const visited = new Uint8Array(W*H);
      const at = (x,y) => labels[y*W+x];
      for (let y=0; y<H; y++) for (let x=0; x<W; x++) {
        const idx = y*W+x; if (visited[idx]) continue;
        const k = at(x,y);
        let w=1; while (x+w<W && !visited[y*W+(x+w)] && at(x+w,y)===k) w++;
        let h=1, ok=true;
        while (y+h<H && ok) {
          for (let xx=0; xx<w; xx++) if (visited[(y+h)*W + (x+xx)] || at(x+xx,y+h)!==k) { ok=false; break; }
          if (ok) h++;
        }
        for (let yy=0; yy<h; yy++) for (let xx=0; xx<w; xx++) visited[(y+yy)*W+(x+xx)] = 1;
        rects.push({x,y,w,h,k});
      }
      return rects;
    }

    const rgbToHex = ([r,g,b]) => `#${[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('')}`;

    // Mise en page: horizontal si ça tient, sinon vertical empilé (avec padding)
// Mise en page intelligente : horizontal si possible,
// sinon wrap vertical avec opérateurs sur leur propre ligne.
// Si la cellule est trop petite (ex. 1 px), on n’affiche rien (mode: 'none').
function layoutExpression(expr, rw, rh) {
  const pad = Math.floor(0.08 * Math.min(rw, rh));
  const availW = Math.max(1, rw - 2 * pad);
  const availH = Math.max(1, rh - 2 * pad);

  const estWidth = (text, fs) => Math.ceil((text.length || 1) * fs * 0.6);
  const lineHeight = (fs) => Math.round(fs * 1.2);

  // 1) Tentative horizontale si ça tient
  {
    const fs0 = Math.max(
      6,
      Math.floor(
        Math.min(
          availH * 0.42,
          (availW / Math.max(1, expr.length)) / 0.6
        )
      )
    );
    if (fs0 >= 10 && estWidth(expr, fs0) <= availW) {
      return { mode: 'h', lines: [expr], font: fs0, pad };
    }
  }

  // 2) Verticale avec wrap par tokens et opérateurs sur leur propre ligne
  const tokens = expr.split(/\s+/).filter(Boolean);
  const isOp = (t) => t === '+' || t === '-' || t === '×' || t === '÷';

  for (
    let fs = Math.min(50, Math.max(6, Math.floor(availH * 0.42)));
    fs >= 6;
    fs--
  ) {
    const lines = [];
    let current = '';

    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];
      const candidate = current ? current + ' ' + t : t;

      if (estWidth(candidate, fs) <= availW) {
        current = candidate;
      } else {
        if (current) lines.push(current);
        if (isOp(t)) {
          // centre l’opérateur tout seul sur une ligne
          lines.push(t);
          current = '';
        } else {
          current = t;
          // même seul ne rentre pas => police trop grande pour la largeur
          if (estWidth(current, fs) > availW) {
            current = '';
            break; // on descend la taille de police (boucle fs)
          }
        }
      }
    }
    if (current) lines.push(current);
    if (!lines.length) continue;

    const totalH = lines.length * lineHeight(fs);
    if (totalH <= availH) {
      return { mode: 'v', lines, font: fs, pad };
    }
  }

  // 3) Cellule minuscule : pas de rendu texte
  return { mode: 'none', lines: [], font: 0, pad };
}


    // ------------------------------ App ------------------------------
    function App() {
      const [imageUrl, setImageUrl] = useState(null);
      const [imageInfo, setImageInfo] = useState(null);
      const [cols, setCols] = useState(40);
      const [numColors, setNumColors] = useState(6);
      const [opsMode, setOpsMode] = useState("addsub");
      const [difficulty, setDifficulty] = useState('facile'); // 'facile' | 'moyen' | 'difficile'
      const [seed, setSeed] = useState(1234);
      const [cellPx, setCellPx] = useState(36);
      const [mergeSameColor, setMergeSameColor] = useState(true);
      const [contrast, setContrast] = useState(0);
      const [saturation, setSaturation] = useState(0);

      const [processing, setProcessing] = useState(false);
      const [error, setError] = useState(null);
      const [gridWidth, setGridWidth] = useState(0);
      const [gridHeight, setGridHeight] = useState(0);
      const [cellAssignments, setCellAssignments] = useState([]);
      const [palette, setPalette] = useState([]);

      // Résultats personnalisables par couleur
      const [customResults, setCustomResults] = useState([]); // array de nombres (même longueur que palette)

      const workCanvasRef = useRef(null);
      const previewCanvasRef = useRef(null);

      const SUPPORTED_MIME = new Set(["image/png","image/jpeg","image/webp","image/gif","image/bmp"]);
      const readFileAsDataURL = (file) => new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onerror = () => reject(new Error("Impossible de lire le fichier (FileReader)."));
        fr.onload = () => resolve(String(fr.result));
        fr.readAsDataURL(file);
      });
      async function onFile(file) {
        try {
          setError(null);
          if (!SUPPORTED_MIME.has(file.type)) { setError(`Format non supporté (${file.type||'inconnu'}). Utilise PNG, JPEG, WEBP, GIF ou BMP.`); return; }
          const dataUrl = await readFileAsDataURL(file);
          setImageInfo({ name: file.name, type: file.type, size: file.size });
          setImageUrl(dataUrl);
        } catch (e) {
          console.error(e); setError(e?.message || "Impossible de lire le fichier sélectionné.");
        }
      }

      const loadImage = (url) => new Promise((resolve, reject) => {
        const img = new Image();
        img.decoding = "async";
        img.onload = async () => {
          try { if (typeof img.decode === 'function') await img.decode(); if ((img.naturalWidth||img.width)===0) return reject(new Error('Image sans dimensions.')); resolve(img); }
          catch(err) { if ((img.naturalWidth||img.width)>0) resolve(img); else reject(new Error("Échec du décodage de l'image.")); }
        };
        img.onerror = () => reject(new Error("Impossible de charger l'image (fichier illisible)."));
        img.src = url;
      });

      function applyContrastSaturation(imgData, contrastVal, saturationVal) {
        const d = imgData.data;
        const C = clamp(contrastVal, -100, 100);
        const cf = (259 * (C + 255)) / (255 * (259 - C));
        const S = clamp(saturationVal, -100, 100);
        const sf = 1 + S / 100;
        for (let i=0; i<d.length; i+=4) {
          let r = cf * (d[i] - 128) + 128;
          let g = cf * (d[i+1] - 128) + 128;
          let b = cf * (d[i+2] - 128) + 128;
          const luma = 0.2126*r + 0.7152*g + 0.0722*b;
          r = luma + (r - luma) * sf;
          g = luma + (g - luma) * sf;
          b = luma + (b - luma) * sf;
          d[i]   = clamp(Math.round(r), 0, 255);
          d[i+1] = clamp(Math.round(g), 0, 255);
          d[i+2] = clamp(Math.round(b), 0, 255);
        }
        return imgData;
      }

      useEffect(() => {
        let cancelled = false;
        async function process() {
          if (!imageUrl) return;
          setProcessing(true); setError(null);
          try {
            const img = await loadImage(imageUrl); if (cancelled) return;
            const iw = img.naturalWidth || img.width || 0;
            const ih = img.naturalHeight || img.height || 0;
            if (iw===0 || ih===0) throw new Error("Dimensions d'image invalides.");
            const ratio = ih/iw || 1;
            const gw = clamp(Math.min(cols, iw), 4, Math.max(4, iw));
            const gh = clamp(Math.round(gw*ratio), 4, Math.max(4, ih));
            setGridWidth(gw); setGridHeight(gh);
            const canvas = workCanvasRef.current; if (!canvas) throw new Error("Canvas de travail introuvable.");
            const ctx = canvas.getContext('2d'); if (!ctx) throw new Error("Contexte 2D non disponible.");
            canvas.width = gw; canvas.height = gh; ctx.clearRect(0,0,gw,gh); ctx.drawImage(img, 0,0, gw, gh);
            let imgData; try { imgData = ctx.getImageData(0,0,gw,gh); } catch { throw new Error("Impossible de lire les pixels. Choisis un autre fichier (PNG/JPEG/WEBP)."); }
            imgData = applyContrastSaturation(imgData, contrast, saturation);
            ctx.putImageData(imgData, 0, 0);
            const points = new Array(gw*gh);
            for (let y=0; y<gh; y++) for (let x=0; x<gw; x++) { const i=(y*gw+x)*4; points[y*gw+x] = [imgData.data[i], imgData.data[i+1], imgData.data[i+2]]; }
            const { centers, labels } = kmeans(points, numColors, 24, seed);
            if (cancelled) return;
            const newPalette = centers.map(c => [Math.round(c[0]), Math.round(c[1]), Math.round(c[2])]);
            setPalette(newPalette);
            setCustomResults((prev) => {
              const arr = prev.slice(0, newPalette.length);
              for (let i=arr.length; i<newPalette.length; i++) arr[i] = i + 2;
              return arr;
            });
            setCellAssignments(labels);
          } catch (e) { console.error(e); setError(e?.message || "Échec du traitement de l'image."); }
          finally { if (!cancelled) setProcessing(false); }
        }
        process(); return () => { cancelled = true; };
      }, [imageUrl, cols, numColors, seed, contrast, saturation]);

      // Mappage résultat -> couleur palette (valeurs modifiables)
      const numberColorMap = useMemo(() => {
        return palette.map((color, i) => ({ value: Math.max(0, Math.floor(customResults[i] ?? (i+2))), color }));
      }, [palette, customResults]);

      // SVG de la grille
      const svgMarkup = useMemo(() => {
        if (!gridWidth || !gridHeight || !cellAssignments.length || !palette.length) return "";
        const rng = mulberry32(seed);
        const cellSize = clamp(cellPx, 16, 200);
        const Wpx = gridWidth * cellSize;
        const Hpx = gridHeight * cellSize;
        const LEGEND_H = 120;
        const exprBank = {};
        for (const e of numberColorMap) exprBank[e.value] = exprBankForResult(e.value, opsMode, rng, difficulty);
        const rects = mergeSameColor
          ? mergeRectangles(cellAssignments, gridWidth, gridHeight)
          : cellAssignments.map((k, i) => ({ x: i%gridWidth, y: Math.floor(i/gridWidth), w:1, h:1, k }));
        let s = `<?xml version="1.0" encoding="UTF-8"?>\n`;
        s += `<svg xmlns='http://www.w3.org/2000/svg' width='${Wpx}' height='${Hpx + LEGEND_H}' viewBox='0 0 ${Wpx} ${Hpx + LEGEND_H}'>`;
        s += `<rect x='0' y='0' width='${Wpx}' height='${Hpx + LEGEND_H}' fill='white'/>`;
        for (const r of rects) {
          const cx=r.x*cellSize, cy=r.y*cellSize, rw=r.w*cellSize, rh=r.h*cellSize;
          const resultVal = (numberColorMap[r.k]?.value ?? 0);
          const exprs = exprBank[resultVal] || [String(resultVal)];
          const expr = exprs[(r.x + r.y + r.k) % exprs.length];
          const L = layoutExpression(expr, rw, rh);
          s += `<rect x='${cx}' y='${cy}' width='${rw}' height='${rh}' fill='none' stroke='black' stroke-width='1'/>`;
          if (L.mode === 'h') {
            s += `<text x='${cx + rw/2}' y='${cy + rh/2}' font-family='monospace' font-size='${L.font}' text-anchor='middle' dominant-baseline='middle'>${expr}</text>`;
          } else {
            const lh = Math.round(L.font * 1.2);
            const totalH = lh * L.lines.length;
            let y0 = cy + (rh - totalH) / 2 + L.font * 0.85;
            for (let i=0; i<L.lines.length; i++) {
              const ly = y0 + i*lh;
              s += `<text x='${cx + rw/2}' y='${ly}' font-family='monospace' font-size='${L.font}' text-anchor='middle' dominant-baseline='middle'>${L.lines[i]}</text>`;
            }
          }
        }
        const legendY = Hpx + 16;
        s += `<g>`;
        s += `<text x='8' y='${legendY}' font-family='sans-serif' font-size='14' font-weight='bold'>Légende: résultat → couleur</text>`;
        let lx=8, ly=legendY+12;
        for (let i=0; i<numberColorMap.length; i++) {
          const { value, color } = numberColorMap[i];
          s += `<rect x='${lx}' y='${ly}' width='18' height='18' fill='${rgbToHex(color)}' stroke='#333'/>`;
          s += `<text x='${lx+26}' y='${ly+14}' font-family='sans-serif' font-size='12'>= ${value}</text>`;
          lx += 120; if (lx > Wpx - 140) { lx = 8; ly += 28; }
        }
        s += `</g>`;
        s += `</svg>`;
        return s;
      }, [gridWidth, gridHeight, cellAssignments, palette, opsMode, numberColorMap, seed, mergeSameColor, cellPx, difficulty]);

      // Aperçu coloré (canvas)
      useEffect(() => {
        if (!gridWidth || !gridHeight || !cellAssignments.length || !palette.length) return;
        const canvas = previewCanvasRef.current; if (!canvas) return;
        const cs = 6, W = gridWidth*cs, H = gridHeight*cs; canvas.width=W; canvas.height=H;
        const ctx = canvas.getContext('2d'); if (!ctx) return;
        for (let y=0; y<gridHeight; y++) for (let x=0; x<gridWidth; x++) {
          const idx=y*gridWidth+x; const k=cellAssignments[idx]; const [r,g,b] = palette[k];
          ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fillRect(x*cs, y*cs, cs, cs);
        }
      }, [gridWidth, gridHeight, cellAssignments, palette]);

      // Rendu sur Canvas (pour PNG en onglet)
      function renderGridToCanvas(scale = 2) {
        if (!gridWidth || !gridHeight || !cellAssignments.length || !palette.length) return null;
        const cellSize = clamp(cellPx, 16, 200);
        const W = gridWidth * cellSize; const H = gridHeight * cellSize; const LEGEND_H = 120;
        const rects = mergeSameColor ? mergeRectangles(cellAssignments, gridWidth, gridHeight)
          : cellAssignments.map((k,i)=>({x:i%gridWidth, y:Math.floor(i/gridWidth), w:1, h:1, k}));
        const results = numberColorMap.map(e=>e.value);
        const rng = mulberry32(seed); const exprBank = {}; for (const r of results) exprBank[r] = exprBankForResult(r, opsMode, rng, difficulty);
        const canvas = document.createElement('canvas'); canvas.width=Math.max(1,Math.floor(W*scale)); canvas.height=Math.max(1,Math.floor((H+LEGEND_H)*scale));
        const ctx = canvas.getContext('2d'); if (!ctx) return null;
        ctx.scale(scale, scale); ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H+LEGEND_H); ctx.strokeStyle='#000';
        for (const r of rects) {
          const cx=r.x*cellSize, cy=r.y*cellSize, rw=r.w*cellSize, rh=r.h*cellSize;
          ctx.lineWidth = 1; ctx.strokeRect(cx+0.5, cy+0.5, rw-1, rh-1);
          const val = numberColorMap[r.k]?.value ?? 0; const exprs = exprBank[val] || [String(val)];
          const expr = exprs[(r.x + r.y + r.k) % exprs.length];
          const L = layoutExpression(expr, rw, rh);
          ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle='#000';
          if (L.mode === 'h') {
            ctx.font = `${L.font}px monospace`;
            ctx.fillText(expr, cx+rw/2, cy+rh/2);
          } else {
            const lh = Math.round(L.font * 1.2);
            let y0 = cy + (rh - (lh * L.lines.length)) / 2 + L.font * 0.85;
            ctx.font = `${L.font}px monospace`;
            for (let i=0; i<L.lines.length; i++) {
              ctx.fillText(L.lines[i], cx + rw/2, y0 + i*lh);
            }
          }
        }
        ctx.fillStyle='#000'; ctx.font='14px sans-serif'; ctx.fillText('Légende: résultat → couleur', 8, H+16);
        let lx=8, ly=H+28; for (let i=0; i<numberColorMap.length; i++) { const {value,color} = numberColorMap[i];
          ctx.fillStyle=`rgb(${color[0]},${color[1]},${color[2]})`; ctx.strokeStyle='#333'; ctx.fillRect(lx,ly,18,18); ctx.strokeRect(lx,ly,18,18);
          ctx.fillStyle='#000'; ctx.font='12px sans-serif'; ctx.fillText(`= ${value}`, lx+26, ly+14); lx+=120; if (lx>W-140) { lx=8; ly+=28; } }
        return canvas;
      }

      function openPNGInNewTab() {
        const canvas = renderGridToCanvas(2);
        if (!canvas) { setError('Échec export PNG: canvas non rendu.'); return; }
        const dataURL = canvas.toDataURL('image/png');
        const w = window.open(); if (w) { w.document.write(`<img src="${dataURL}" style="width:100%;height:auto;"/>`); w.document.close(); }
      }

      // Gestion des changements manuels des résultats
      function updateResultAt(i, val) {
        setCustomResults((prev) => {
          const next = prev.slice();
          const n = Number(val);
          next[i] = Number.isFinite(n) ? clamp(Math.round(n), 0, 9999) : (next[i] ?? i+2);
          return next;
        });
      }
      function resetResults() {
        setCustomResults(palette.map((_, i) => i + 2));
      }

      return (
        <div>
          <h1 className="text-3xl font-bold mb-2">Coloriage magique à partir d'une image</h1>
          <p className="mb-4 text-slate-600">Charge une image locale, ajuste contraste/saturation, choisis les opérations et la difficulté. Tu peux aussi <strong>modifier le résultat</strong> associé à chaque couleur (nombres grands possibles). Le texte s'ajuste automatiquement (horizontal ou vertical) avec un léger padding.</p>

          <div className="grid md:grid-cols-3 gap-6">
            <div className="md:col-span-1 bg-white rounded-2xl shadow p-4 space-y-4">
              <div>
                <label className="block text-sm font-medium mb-2">Image (PNG, JPEG, WEBP, GIF, BMP)</label>
                <input type="file" accept="image/*" onChange={(e)=>{ const f=e.currentTarget.files?.[0]; if(f) onFile(f); e.currentTarget.value=''; }} className="block w-full text-sm" />
                {imageInfo && (
                  <p className="mt-1 text-xs text-slate-500">Sélection : {imageInfo.name || '-'} ({imageInfo.type || '-'}{imageInfo.size ? ', '+Math.round(imageInfo.size/1024)+' Ko' : ''})</p>
                )}
              </div>

              <div>
                <label className="block text-sm font-medium">Colonnes de la grille : {cols}</label>
                <input type="range" min={10} max={120} value={cols} onChange={(e)=>setCols(parseInt(e.currentTarget.value))} className="w-full" />
              </div>

              <div>
                <label className="block text-sm font-medium">Nombre de couleurs : {numColors}</label>
                <input type="range" min={2} max={12} value={numColors} onChange={(e)=>setNumColors(parseInt(e.currentTarget.value))} className="w-full" />
              </div>

              <div>
                <label className="block text-sm font-medium mb-1">Type d'opérations</label>
                <select className="w-full border rounded-lg p-2" value={opsMode} onChange={(e)=>setOpsMode(e.currentTarget.value)}>
                  <option value="add">Additions</option>
                  <option value="addsub">Additions & soustractions</option>
                  <option value="mult">Multiplications</option>
                  <option value="multdiv">Multiplications & divisions</option>
                  <option value="mix">Mélange (toutes)</option>
                </select>
              </div>

              <div>
                <label className="block text-sm font-medium mb-1">Niveau de difficulté</label>
                <select className="w-full border rounded-lg p-2" value={difficulty} onChange={(e)=>setDifficulty(e.currentTarget.value)}>
                  <option value="facile">Facile</option>
                  <option value="moyen">Moyen</option>
                  <option value="difficile">Difficile</option>
                </select>
              </div>

              <div className="grid grid-cols-2 gap-3">
                <div>
                  <label className="block text-sm font-medium">Taille des cases (px) : {cellPx}</label>
                  <input type="range" min={16} max={120} value={cellPx} onChange={(e)=>setCellPx(parseInt(e.currentTarget.value))} className="w-full" />
                </div>
                <label className="flex items-center gap-2 mt-6">
                  <input type="checkbox" checked={mergeSameColor} onChange={(e)=>setMergeSameColor(e.currentTarget.checked)} />
                  <span className="text-sm">Fusionner cellules identiques</span>
                </label>
              </div>

              <div>
                <label className="block text-sm font-medium">Contraste : {contrast}</label>
                <input type="range" min={-100} max={100} value={contrast} onChange={(e)=>setContrast(parseInt(e.currentTarget.value))} className="w-full" />
              </div>
              <div>
                <label className="block text-sm font-medium">Saturation : {saturation}</label>
                <input type="range" min={-100} max={100} value={saturation} onChange={(e)=>setSaturation(parseInt(e.currentTarget.value))} className="w-full" />
              </div>

              <div className="flex gap-2">
                <button type="button" onClick={openPNGInNewTab} className="px-3 py-2 rounded-xl bg-slate-700 text-white hover:opacity-90" disabled={!svgMarkup}>
                  Ouvrir PNG dans un onglet
                </button>
              </div>

              {processing && <div className="text-sm text-amber-600">Traitement en cours…</div>}
              {error && <div className="text-sm text-red-600">{error}</div>}
            </div>

            <div className="md:col-span-1 bg-white rounded-2xl shadow p-4">
              <h2 className="font-semibold mb-2">Aperçu coloré (palette réduite)</h2>
              {imageUrl ? (
                <canvas ref={previewCanvasRef} className="w-full h-auto border rounded-lg" />
              ) : (
                <div className="text-sm text-slate-500">Importe une image pour voir l'aperçu.</div>
              )}
            </div>

            <div className="md:col-span-1 bg-white rounded-2xl shadow p-4">
              <h2 className="font-semibold mb-2">Grille à colorier (SVG)</h2>
              {svgMarkup ? (
                <div className="border rounded-lg overflow-auto max-h-[60vh] p-2 bg-slate-50">
                  <div dangerouslySetInnerHTML={{ __html: svgMarkup }} />
                </div>
              ) : (
                <div className="text-sm text-slate-500">La grille s'affichera ici.</div>
              )}
            </div>
          </div>

          <canvas ref={workCanvasRef} className="hidden" />

          {palette.length > 0 && (
            <div className="mt-6 bg-white rounded-2xl shadow p-4">
              <h3 className="font-semibold mb-3">Résultats par couleur</h3>
              <div className="grid sm:grid-cols-2 gap-3">
                {palette.map((c,i)=> (
                  <label key={i} className="flex items-center gap-3 p-2 rounded-lg border">
                    <span className="inline-flex items-center gap-2 min-w-[88px]">
                      <span className="w-6 h-6 rounded border" style={{ backgroundColor: `rgb(${c[0]},${c[1]},${c[2]})` }} />
                      <span className="text-xs text-slate-600">Couleur {i+1}</span>
                    </span>
                    <span className="text-xs text-slate-500">Résultat :</span>
                    <input
                      type="number"
                      min={0}
                      max={9999}
                      value={customResults[i] ?? (i+2)}
                      onChange={(e)=>updateResultAt(i, e.currentTarget.value)}
                      className="w-24 px-2 py-1 border rounded-md text-sm"
                    />
                  </label>
                ))}
              </div>
              <div className="mt-3 flex gap-2">
                <button onClick={resetResults} className="px-3 py-1.5 rounded-md bg-slate-100 hover:bg-slate-200 border">Réinitialiser</button>
              </div>
              <p className="text-xs text-slate-500 mt-3">Ces valeurs sont utilisées pour générer les opérations et pour la légende. Elles peuvent être supérieures à 20. Aucun résultat négatif n'est généré ; les divisions sont exactes.</p>
            </div>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>

