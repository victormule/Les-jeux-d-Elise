<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Coloriage Magique – Les jeux d'Élise</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <!-- Tailwind (CDN) pour un style rapide et propre) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + ReactDOM (UMD) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Babel pour transpiler JSX directement dans le navigateur (pratique pour un fichier unique) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html, body { height: 100%; }
  </style>
</head>
<body class="min-h-screen bg-slate-50 text-slate-900">
  <div class="max-w-6xl mx-auto p-6">
    <a href="index.html" class="inline-block text-sm text-slate-500 hover:text-slate-700 mb-2">← Retour aux jeux</a>
    <div id="root"></div>
  </div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    // ------------------------------ Helpers ------------------------------
    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
    const mulberry32 = (a) => () => {
      let t = (a += 0x6d2b79f5);
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };

    function kmeans(points, k, maxIter = 20, seedVal = 1) {
      if (!points.length) return { centers: [], labels: [] };
      k = clamp(k, 1, points.length);
      const rand = mulberry32(seedVal);
      const centers = [];
      const used = new Set();
      while (centers.length < k) {
        const idx = Math.floor(rand() * points.length);
        if (!used.has(idx)) { used.add(idx); centers.push(points[idx].slice()); }
      }
      const labels = new Array(points.length).fill(0);
      const dist2 = (a, b) => (a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2;
      for (let it=0; it<maxIter; it++) {
        let changed = false;
        for (let i=0; i<points.length; i++) {
          let best = 0, bestd = Infinity;
          for (let c=0; c<centers.length; c++) {
            const d = dist2(points[i], centers[c]);
            if (d < bestd) { bestd = d; best = c; }
          }
          if (labels[i] !== best) { labels[i] = best; changed = true; }
        }
        const sums = Array.from({length:k}, () => [0,0,0,0]);
        for (let i=0; i<points.length; i++) {
          const c = labels[i];
          sums[c][0]+=points[i][0]; sums[c][1]+=points[i][1]; sums[c][2]+=points[i][2]; sums[c][3]++;
        }
        for (let c=0; c<k; c++) if (sums[c][3]>0) centers[c] = [sums[c][0]/sums[c][3], sums[c][1]/sums[c][3], sums[c][2]/sums[c][3]];
        if (!changed) break;
      }
      return { centers, labels };
    }

    function exprBankForResult(target, mode, rng) {
      const list = [];
      const pushUnique = (s) => { if (!list.includes(s)) list.push(s); };
      if (["add","addsub","mix"].includes(mode)) {
        for (let a=0; a<=target; a++) { const b = target-a; if (a>=0 && b>=0) pushUnique(`${a} + ${b}`); }
      }
      if (["addsub","mix"].includes(mode)) {
        for (let a=target; a<=target+20; a++) { const b=a-target; if (b>=0) pushUnique(`${a} - ${b}`); }
      }
      if (["mult","multdiv","mix"].includes(mode)) {
        for (let a=1; a<=12; a++) if (target % a === 0) { const b = target/a; if (b>=1 && b<=12) pushUnique(`${a} × ${b}`); }
      }
      if (["multdiv","mix"].includes(mode)) {
        for (let b=1; b<=12; b++) { const a = target*b; if (a<=144) pushUnique(`${a} ÷ ${b}`); }
      }
      for (let i=list.length-1; i>0; i--) { const j = Math.floor(rng()*(i+1)); [list[i],list[j]] = [list[j],list[i]]; }
      return list;
    }

    function mergeRectangles(labels, W, H) {
      const rects = [];
      const visited = new Uint8Array(W*H);
      const at = (x,y) => labels[y*W+x];
      for (let y=0; y<H; y++) for (let x=0; x<W; x++) {
        const idx = y*W+x; if (visited[idx]) continue;
        const k = at(x,y);
        let w=1; while (x+w<W && !visited[y*W+(x+w)] && at(x+w,y)===k) w++;
        let h=1, ok=true;
        while (y+h<H && ok) {
          for (let xx=0; xx<w; xx++) if (visited[(y+h)*W + (x+xx)] || at(x+xx,y+h)!==k) { ok=false; break; }
          if (ok) h++;
        }
        for (let yy=0; yy<h; yy++) for (let xx=0; xx<w; xx++) visited[(y+yy)*W+(x+xx)] = 1;
        rects.push({x,y,w,h,k});
      }
      return rects;
    }

    const rgbToHex = ([r,g,b]) => `#${[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('')}`;
    const computeFontSize = (expr, rw, rh) => {
      const charCount = Math.max(1, expr.length);
      const charWidthFactor = 0.6;
      const maxByHeight = clamp(rh*0.42, 10, 64);
      const maxByWidth = clamp((rw*0.9)/(charCount*charWidthFactor), 10, 64);
      return Math.floor(Math.min(maxByHeight, maxByWidth));
    };

    // ------------------------------ App ------------------------------
    function App() {
      const [imageUrl, setImageUrl] = useState(null);
      const [imageInfo, setImageInfo] = useState(null);
      const [cols, setCols] = useState(40);
      const [numColors, setNumColors] = useState(6);
      const [opsMode, setOpsMode] = useState("addsub");
      const [seed, setSeed] = useState(1234);
      const [cellPx, setCellPx] = useState(36);
      const [mergeSameColor, setMergeSameColor] = useState(true);
      const [contrast, setContrast] = useState(0);
      const [saturation, setSaturation] = useState(0);

      const [processing, setProcessing] = useState(false);
      const [error, setError] = useState(null);
      const [gridWidth, setGridWidth] = useState(0);
      const [gridHeight, setGridHeight] = useState(0);
      const [cellAssignments, setCellAssignments] = useState([]);
      const [palette, setPalette] = useState([]);

      const workCanvasRef = useRef(null);
      const previewCanvasRef = useRef(null);

      const SUPPORTED_MIME = new Set(["image/png","image/jpeg","image/webp","image/gif","image/bmp"]);
      const readFileAsDataURL = (file) => new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onerror = () => reject(new Error("Impossible de lire le fichier (FileReader)."));
        fr.onload = () => resolve(String(fr.result));
        fr.readAsDataURL(file);
      });
      async function onFile(file) {
        try {
          setError(null);
          if (!SUPPORTED_MIME.has(file.type)) { setError(`Format non supporté (${file.type||'inconnu'}). Utilise PNG, JPEG, WEBP, GIF ou BMP.`); return; }
          const dataUrl = await readFileAsDataURL(file);
          setImageInfo({ name: file.name, type: file.type, size: file.size });
          setImageUrl(dataUrl);
        } catch (e) {
          console.error(e); setError(e?.message || "Impossible de lire le fichier sélectionné.");
        }
      }

      const loadImage = (url) => new Promise((resolve, reject) => {
        const img = new Image();
        img.decoding = "async";
        img.onload = async () => {
          try { if (typeof img.decode === 'function') await img.decode(); if ((img.naturalWidth||img.width)===0) return reject(new Error('Image sans dimensions.')); resolve(img); }
          catch(err) { if ((img.naturalWidth||img.width)>0) resolve(img); else reject(new Error("Échec du décodage de l'image.")); }
        };
        img.onerror = () => reject(new Error("Impossible de charger l'image (fichier illisible)."));
        img.src = url;
      });

      function applyContrastSaturation(imgData, contrastVal, saturationVal) {
        const d = imgData.data;
        const C = clamp(contrastVal, -100, 100);
        const cf = (259 * (C + 255)) / (255 * (259 - C));
        const S = clamp(saturationVal, -100, 100);
        const sf = 1 + S / 100;
        for (let i=0; i<d.length; i+=4) {
          let r = cf * (d[i] - 128) + 128;
          let g = cf * (d[i+1] - 128) + 128;
          let b = cf * (d[i+2] - 128) + 128;
          const luma = 0.2126*r + 0.7152*g + 0.0722*b;
          r = luma + (r - luma) * sf;
          g = luma + (g - luma) * sf;
          b = luma + (b - luma) * sf;
          d[i]   = clamp(Math.round(r), 0, 255);
          d[i+1] = clamp(Math.round(g), 0, 255);
          d[i+2] = clamp(Math.round(b), 0, 255);
        }
        return imgData;
      }

      useEffect(() => {
        let cancelled = false;
        async function process() {
          if (!imageUrl) return;
          setProcessing(true); setError(null);
          try {
            const img = await loadImage(imageUrl); if (cancelled) return;
            const iw = img.naturalWidth || img.width || 0;
            const ih = img.naturalHeight || img.height || 0;
            if (iw===0 || ih===0) throw new Error("Dimensions d'image invalides.");
            const ratio = ih/iw || 1;
            const gw = clamp(Math.min(cols, iw), 4, Math.max(4, iw));
            const gh = clamp(Math.round(gw*ratio), 4, Math.max(4, ih));
            setGridWidth(gw); setGridHeight(gh);
            const canvas = workCanvasRef.current; if (!canvas) throw new Error("Canvas de travail introuvable.");
            const ctx = canvas.getContext('2d'); if (!ctx) throw new Error("Contexte 2D non disponible.");
            canvas.width = gw; canvas.height = gh; ctx.clearRect(0,0,gw,gh); ctx.drawImage(img, 0,0, gw, gh);
            let imgData; try { imgData = ctx.getImageData(0,0,gw,gh); } catch { throw new Error("Impossible de lire les pixels. Choisis un autre fichier (PNG/JPEG/WEBP)."); }
            imgData = applyContrastSaturation(imgData, contrast, saturation);
            ctx.putImageData(imgData, 0, 0);
            const points = new Array(gw*gh);
            for (let y=0; y<gh; y++) for (let x=0; x<gw; x++) { const i=(y*gw+x)*4; points[y*gw+x] = [imgData.data[i], imgData.data[i+1], imgData.data[i+2]]; }
            const { centers, labels } = kmeans(points, numColors, 24, seed);
            if (cancelled) return;
            setPalette(centers.map(c => [Math.round(c[0]), Math.round(c[1]), Math.round(c[2])]));
            setCellAssignments(labels);
          } catch (e) { console.error(e); setError(e?.message || "Échec du traitement de l'image."); }
          finally { if (!cancelled) setProcessing(false); }
        }
        process(); return () => { cancelled = true; };
      }, [imageUrl, cols, numColors, seed, contrast, saturation]);

      const numberColorMap = useMemo(() => palette.map((color, i) => ({ value: i+2, color })), [palette]);

      const svgMarkup = useMemo(() => {
        if (!gridWidth || !gridHeight || !cellAssignments.length || !palette.length) return "";
        const rng = mulberry32(seed);
        const cellSize = clamp(cellPx, 16, 200);
        const Wpx = gridWidth * cellSize;
        const Hpx = gridHeight * cellSize;
        const LEGEND_H = 120;
        const exprBank = {};
        for (const e of numberColorMap) exprBank[e.value] = exprBankForResult(e.value, opsMode, rng);
        const rects = mergeSameColor
          ? mergeRectangles(cellAssignments, gridWidth, gridHeight)
          : cellAssignments.map((k, i) => ({ x: i%gridWidth, y: Math.floor(i/gridWidth), w:1, h:1, k }));
        let s = `<?xml version="1.0" encoding="UTF-8"?>\n`;
        s += `<svg xmlns='http://www.w3.org/2000/svg' width='${Wpx}' height='${Hpx + LEGEND_H}' viewBox='0 0 ${Wpx} ${Hpx + LEGEND_H}'>`;
        s += `<rect x='0' y='0' width='${Wpx}' height='${Hpx + LEGEND_H}' fill='white'/>`;
        for (const r of rects) {
          const cx=r.x*cellSize, cy=r.y*cellSize, rw=r.w*cellSize, rh=r.h*cellSize;
          const resultVal = (numberColorMap[r.k]?.value ?? 0);
          const exprs = exprBank[resultVal] || [String(resultVal)];
          const expr = exprs[(r.x + r.y + r.k) % exprs.length];
          const fs = computeFontSize(expr, rw, rh);
          s += `<rect x='${cx}' y='${cy}' width='${rw}' height='${rh}' fill='none' stroke='black' stroke-width='1'/>`;
          s += `<text x='${cx + rw/2}' y='${cy + rh/2}' font-family='monospace' font-size='${fs}' text-anchor='middle' dominant-baseline='middle'>${expr}</text>`;
        }
        const legendY = Hpx + 16;
        s += `<g>`;
        s += `<text x='8' y='${legendY}' font-family='sans-serif' font-size='14' font-weight='bold'>Légende: résultat → couleur</text>`;
        let lx=8, ly=legendY+12;
        for (let i=0; i<numberColorMap.length; i++) {
          const { value, color } = numberColorMap[i];
          s += `<rect x='${lx}' y='${ly}' width='18' height='18' fill='${rgbToHex(color)}' stroke='#333'/>`;
          s += `<text x='${lx+26}' y='${ly+14}' font-family='sans-serif' font-size='12'>= ${value}</text>`;
          lx += 120; if (lx > Wpx - 140) { lx = 8; ly += 28; }
        }
        s += `</g>`;
        s += `</svg>`;
        return s;
      }, [gridWidth, gridHeight, cellAssignments, palette, opsMode, numberColorMap, seed, mergeSameColor, cellPx]);

      useEffect(() => {
        if (!gridWidth || !gridHeight || !cellAssignments.length || !palette.length) return;
        const canvas = previewCanvasRef.current; if (!canvas) return;
        const cs = 6, W = gridWidth*cs, H = gridHeight*cs; canvas.width=W; canvas.height=H;
        const ctx = canvas.getContext('2d'); if (!ctx) return;
        for (let y=0; y<gridHeight; y++) for (let x=0; x<gridWidth; x++) {
          const idx=y*gridWidth+x; const k=cellAssignments[idx]; const [r,g,b] = palette[k];
          ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fillRect(x*cs, y*cs, cs, cs);
        }
      }, [gridWidth, gridHeight, cellAssignments, palette]);

      function renderGridToCanvas(scale = 2) {
        if (!gridWidth || !gridHeight || !cellAssignments.length || !palette.length) return null;
        const cellSize = clamp(cellPx, 16, 200);
        const W = gridWidth * cellSize; const H = gridHeight * cellSize; const LEGEND_H = 120;
        const rects = mergeSameColor ? mergeRectangles(cellAssignments, gridWidth, gridHeight)
          : cellAssignments.map((k,i)=>({x:i%gridWidth, y:Math.floor(i/gridWidth), w:1, h:1, k}));
        const results = numberColorMap.map(e=>e.value);
        const rng = mulberry32(seed); const exprBank = {}; for (const r of results) exprBank[r] = exprBankForResult(r, opsMode, rng);
        const canvas = document.createElement('canvas'); canvas.width=Math.max(1,Math.floor(W*scale)); canvas.height=Math.max(1,Math.floor((H+LEGEND_H)*scale));
        const ctx = canvas.getContext('2d'); if (!ctx) return null;
        ctx.scale(scale, scale); ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H+LEGEND_H); ctx.strokeStyle='#000';
        for (const r of rects) {
          const cx=r.x*cellSize, cy=r.y*cellSize, rw=r.w*cellSize, rh=r.h*cellSize;
          ctx.lineWidth = 1; ctx.strokeRect(cx+0.5, cy+0.5, rw-1, rh-1);
          const val = numberColorMap[r.k]?.value ?? 0; const exprs = exprBank[val] || [String(val)];
          const expr = exprs[(r.x + r.y + r.k) % exprs.length]; const fs = computeFontSize(expr, rw, rh);
          ctx.font = `${fs}px monospace`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle='#000';
          ctx.fillText(expr, cx+rw/2, cy+rh/2);
        }
        ctx.fillStyle='#000'; ctx.font='14px sans-serif'; ctx.fillText('Légende: résultat → couleur', 8, H+16);
        let lx=8, ly=H+28; for (let i=0; i<numberColorMap.length; i++) { const {value,color} = numberColorMap[i];
          ctx.fillStyle=`rgb(${color[0]},${color[1]},${color[2]})`; ctx.strokeStyle='#333'; ctx.fillRect(lx,ly,18,18); ctx.strokeRect(lx,ly,18,18);
          ctx.fillStyle='#000'; ctx.font='12px sans-serif'; ctx.fillText(`= ${value}`, lx+26, ly+14); lx+=120; if (lx>W-140) { lx=8; ly+=28; } }
        return canvas;
      }

      function openPNGInNewTab() {
        const canvas = renderGridToCanvas(2);
        if (!canvas) { setError('Échec export PNG: canvas non rendu.'); return; }
        const dataURL = canvas.toDataURL('image/png');
        const w = window.open(); if (w) { w.document.write(`<img src="${dataURL}" style="width:100%;height:auto;"/>`); w.document.close(); }
      }

      return (
        <div>
          <h1 className="text-3xl font-bold mb-2">Coloriage magique à partir d'une image</h1>
          <p className="mb-4 text-slate-600">Charge une image locale, ajuste le contraste/saturation avant pixelisation pour réduire la plage de couleurs, choisis les paramètres et ouvre le PNG dans un onglet pour l'enregistrer.</p>

          <div className="grid md:grid-cols-3 gap-6">
            <div className="md:col-span-1 bg-white rounded-2xl shadow p-4 space-y-4">
              <div>
                <label className="block text-sm font-medium mb-2">Image (PNG, JPEG, WEBP, GIF, BMP)</label>
                <input type="file" accept="image/*" onChange={(e)=>{ const f=e.currentTarget.files?.[0]; if(f) onFile(f); e.currentTarget.value=''; }} className="block w-full text-sm" />
                {imageInfo && (
                  <p className="mt-1 text-xs text-slate-500">Sélection : {imageInfo.name || '-'} ({imageInfo.type || '-'}{imageInfo.size ? ', '+Math.round(imageInfo.size/1024)+' Ko' : ''})</p>
                )}
              </div>

              <div>
                <label className="block text-sm font-medium">Colonnes de la grille : {cols}</label>
                <input type="range" min={10} max={120} value={cols} onChange={(e)=>setCols(parseInt(e.currentTarget.value))} className="w-full" />
              </div>

              <div>
                <label className="block text-sm font-medium">Nombre de couleurs : {numColors}</label>
                <input type="range" min={2} max={12} value={numColors} onChange={(e)=>setNumColors(parseInt(e.currentTarget.value))} className="w-full" />
              </div>

              <div>
                <label className="block text-sm font-medium mb-1">Type d'opérations</label>
                <select className="w-full border rounded-lg p-2" value={opsMode} onChange={(e)=>setOpsMode(e.currentTarget.value)}>
                  <option value="add">Additions</option>
                  <option value="addsub">Additions & soustractions</option>
                  <option value="mult">Multiplications</option>
                  <option value="multdiv">Multiplications & divisions</option>
                  <option value="mix">Mélange (toutes)</option>
                </select>
              </div>

              <div className="grid grid-cols-2 gap-3">
                <div>
                  <label className="block text-sm font-medium">Taille des cases (px) : {cellPx}</label>
                  <input type="range" min={16} max={120} value={cellPx} onChange={(e)=>setCellPx(parseInt(e.currentTarget.value))} className="w-full" />
                </div>
                <label className="flex items-center gap-2 mt-6">
                  <input type="checkbox" checked={mergeSameColor} onChange={(e)=>setMergeSameColor(e.currentTarget.checked)} />
                  <span className="text-sm">Fusionner cellules identiques</span>
                </label>
              </div>

              <div>
                <label className="block text-sm font-medium">Contraste : {contrast}</label>
                <input type="range" min={-100} max={100} value={contrast} onChange={(e)=>setContrast(parseInt(e.currentTarget.value))} className="w-full" />
              </div>
              <div>
                <label className="block text-sm font-medium">Saturation : {saturation}</label>
                <input type="range" min={-100} max={100} value={saturation} onChange={(e)=>setSaturation(parseInt(e.currentTarget.value))} className="w-full" />
              </div>

              <div className="flex gap-2">
                <button type="button" onClick={openPNGInNewTab} className="px-3 py-2 rounded-xl bg-slate-700 text-white hover:opacity-90" disabled={!svgMarkup}>
                  Ouvrir PNG dans un onglet
                </button>
              </div>

              {processing && <div className="text-sm text-amber-600">Traitement en cours…</div>}
              {error && <div className="text-sm text-red-600">{error}</div>}
            </div>

            <div className="md:col-span-1 bg-white rounded-2xl shadow p-4">
              <h2 className="font-semibold mb-2">Aperçu coloré (palette réduite)</h2>
              {imageUrl ? (
                <canvas ref={previewCanvasRef} className="w-full h-auto border rounded-lg" />
              ) : (
                <div className="text-sm text-slate-500">Importe une image pour voir l'aperçu.</div>
              )}
            </div>

            <div className="md:col-span-1 bg-white rounded-2xl shadow p-4">
              <h2 className="font-semibold mb-2">Grille à colorier (SVG)</h2>
              {svgMarkup ? (
                <div className="border rounded-lg overflow-auto max-h-[60vh] p-2 bg-slate-50">
                  <div dangerouslySetInnerHTML={{ __html: svgMarkup }} />
                </div>
              ) : (
                <div className="text-sm text-slate-500">La grille s'affichera ici.</div>
              )}
            </div>
          </div>

          <canvas ref={workCanvasRef} className="hidden" />

          {palette.length > 0 && (
            <div className="mt-6 bg-white rounded-2xl shadow p-4">
              <h3 className="font-semibold mb-2">Palette détectée ({palette.length})</h3>
              <div className="flex flex-wrap gap-3">
                {palette.map((c,i)=> (
                  <div key={i} className="flex items-center gap-2">
                    <div className="w-6 h-6 rounded border" style={{ backgroundColor: `rgb(${c[0]},${c[1]},${c[2]})` }} />
                    <span className="text-xs text-slate-600">{i+2}</span>
                  </div>
                ))}
              </div>
              <p className="text-xs text-slate-500 mt-2">La légende associe chaque couleur à un résultat (2, 3, 4, …). Les opérations mènent à ces résultats.</p>
            </div>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
